import numpy as np
from imageio import imread
from skimage.color import rgb2gray
import matplotlib.pyplot as plt
import scipy.ndimage.filters
import os

# The change of bases matrix from YIQ to RGB
MAX_COLOR = 255

# The base vector
BASE_VECTOR = np.array([1, 1])

# The lowest resolution image
LOWEST_RESOLUTION = 16


def read_image(filename, representation):
    """
    Read an image with source of 'filename'. Saves the data in a matrix.
    :param filename: The file's source.
    :param representation: The file's representationL RBG or YIQ.
    :return: An matrix of the image, represented by a type of np.float64.
    """
    image = imread(filename)
    data = np.asarray(image, dtype=np.float64)
    if representation == 1:
        data = rgb2gray(data)
    data = data / MAX_COLOR
    return data


def _get_filter_vec(filter_size):
    """
    This function gets the filter's size and returns the right filter vector.
    :param filter_size: A number of the size of the filter.
    :return: The right filter vector.
    """
    returned_vector = BASE_VECTOR
    while returned_vector.size < filter_size:
        returned_vector = np.convolve(returned_vector, BASE_VECTOR)
    returned_vector_sum = np.sum(returned_vector)
    normalized_vector = returned_vector / returned_vector_sum
    return normalized_vector.reshape((1, filter_size))


def _select_every_other_pixel(im):
    """
    This function Gets an image and returns it after it takes every other
    pixel from it.
    :param im: a grayscale image with double values in [0, 1].
    :return: The image after taking every other pixel from it.
    """
    return im[0::2].T[0::2].T


def _blur_image(im, filter_vec):
    """
    This function Gets an image and blur it before selecting every other pixel.
    :param im: a grayscale image with double values in [0, 1].
    :return: The image after the blur.
    """
    im_after_blur = scipy.ndimage.filters.convolve(im, filter_vec)
    im_after_blur = scipy.ndimage.filters.convolve(im_after_blur.T, filter_vec).T
    return im_after_blur


def _expand(gaussian_level, filter):
    """
    This function gets a gaussian level in the pyr and a filter and expands the
    gaussian level by adding zeroes in the odd places.
    :param gaussian_level: the gaussian level in the pyramid.
    :param filter: the filer.
    :return: The gaussian level after expands.
    """
    rows, columns = gaussian_level.shape
    new_rows = int(rows * 2)
    new_columns = int(columns * 2)
    im_new_size = np.zeros((new_rows, new_columns))
    new_image = im_new_size
    new_image[0::2, 0::2] = gaussian_level.copy()
    return _blur_image(new_image, filter)


def build_gaussian_pyramid(im, max_levels, filter_size):
    """
    This function construct a Gaussian pyramid of a given image.
    :param im: a grayscale image with double values in [0, 1].
    :param max_levels: the maximal number of levels1 in the resulting pyramid.
    :param filter_size: the size of the Gaussian filter to be used in
           constracting the pyramid filter.
    :return: The Gaussian pyramid of the image, and the filter_vec.
    """
    pyr = [im]
    image_after_resize = im
    filter_vec = _get_filter_vec(filter_size)
    while len(pyr) < max_levels and image_after_resize.shape[0] >= 2 * LOWEST_RESOLUTION \
            and image_after_resize.shape[1] >= 2 * LOWEST_RESOLUTION:
        image_after_resize = _select_every_other_pixel(_blur_image(image_after_resize,
                                                                   filter_vec))
        pyr.append(image_after_resize)
    return pyr, filter_vec.reshape((1, filter_size))


def build_laplacian_pyramid(im, max_levels, filter_size):
    """
    This function construct a Gaussian pyramid of a given image.
    :param im: a grayscale image with double values in [0, 1].
    :param max_levels: the maximal number of levels1 in the resulting pyramid.
    :param filter_size: the size of the Gaussian filter to be used in
           constracting the pyramid filter.
    :return: pyr - A standart python array.
    """
    pyr = []
    gaussian_pyramid, filter_vec = build_gaussian_pyramid(im, max_levels,
                                                          filter_size)

    for i in range(len(gaussian_pyramid) - 1):
        laplecian_level = gaussian_pyramid[i] - _expand(gaussian_pyramid[i + 1],
                                                        filter_vec * 2)
        pyr.append(laplecian_level)
    pyr.append(gaussian_pyramid[-1])
    return pyr, filter_vec


def laplacian_to_image(lpyr, filter_vec, coeff):
    """
    This function construct a Gaussian pyramid of a given image.
    :param lpyr: is the laplacian pyramid.
    :param filter_vec: The filter that was generated by the second function.
    :param coeff: is a python list.
    :return: pyr - A standart python array.
    """
    lpyr_length = len(lpyr)
    img = lpyr[-1] * coeff[-1]
    for level in range(lpyr_length - 2, -1, -1):
        img = _expand(img, filter_vec * 2) + lpyr[level] * coeff[level]
    return img


def render_pyramid(pyr, levels):
    """
    This function display the pyramid.
    :param pyr: is either a Gaussian or Laplacian pyramid.
    :param levels: is the number of levels ^ 2 to present in the result ≤
           max_levels.
    """
    temp_pyr = pyr.copy()
    rows, columns = pyr[0].shape
    result = np.empty((rows, 0))
    for i in range(levels):
        im = temp_pyr[i]
        im_min = im.min()
        im_max = im.max()
        temp_pyr[i] = (im - np.full(im.shape, im_min)) / 1.0 * (im_max - im_min)

    for i in range(levels):
        new_level = temp_pyr[i]
        result = np.hstack((result, np.vstack((new_level, np.zeros((rows - new_level.shape[0], new_level.shape[1]))))))
    return result



def display_pyramid(pyr, levels):
    """
    This function display the pyramid.
    :param pyr: is either a Gaussian or Laplacian pyramid.
    :param levels: is the number of levels ^ 2 to present in the result ≤
           max_levels.
    """
    plt.figure()
    plt.imshow(render_pyramid(pyr, levels), cmap='gray')
    plt.show()


def calculate_blending_level(mask_pyr_level, im1_pyr_level, im2_pyr_level):
    """
    This function calculates one blending level of the pyr.
    :param mask_pyr_level: The mask's level.
    :param im1_pyr_level: The pyr_1's level.
    :param im2_pyr_level: The pyr_2's level.
    :return: The blending level.
    """
    return np.multiply(mask_pyr_level, im1_pyr_level) + \
           np.multiply(1 - mask_pyr_level, im2_pyr_level)


def pyramid_blending(im1, im2, mask, max_levels, filter_size_im,
                     filter_size_mask):
    """
    This function implementing a pyramid blending as described in the lecture.
    :param im1: is an input grayscale images to be blended.
    :param im2: is an input grayscale images to be blended.
    :param mask: is a boolean (i.e. dtype == np.bool) mask containing True and
                 False representing which parts of im1 and im2 should appear
                 in the resulting im_blend.
    :param max_levels:  is the max_levels parameter you should use when
                        generating the Gaussian and Laplacian pyramids.
    :param filter_size_im: is the size of the Gaussian filter (an odd scalar
                           that represents a squared filter) which defining the
                           filter used in the construction of the Laplacian
                           pyramids of im1 and im2
    :param filter_size_mask: is the size of the Gaussian filter
    :return: The pyramid after blending.
    """
    pyr_blending = []
    mask_pyr = build_gaussian_pyramid(mask.astype(np.float64), max_levels, filter_size_mask)[0]
    im1_pyr, filter_vec_im = build_laplacian_pyramid(im1, max_levels, filter_size_im)
    im2_pyr, filter_vec_im_2 = build_laplacian_pyramid(im2, max_levels, filter_size_im)

    for level in range(len(mask_pyr)):
        pyr_blending.append(calculate_blending_level(mask_pyr[level],
                                                     im1_pyr[level],
                                                     im2_pyr[level]))

    image_after_laplacian = laplacian_to_image(pyr_blending, filter_vec_im,
                                               np.ones(len(mask_pyr)))
    return np.clip(image_after_laplacian, 0, 1)


def relpath(filename):
    """
    A helper function from ex3 description
    """
    return os.path.join(os.path.dirname(__file__), filename)


def blending_images(image1_name, image2_name, mask_name, max_levels,
                     filter_size_im, filter_size_mask):
    """
    This function implements blending between two images.
    :param image1_name: is an input grayscale images to be blended.
    :param image2_name: is an input grayscale images to be blended.
    :param mask_name: is a boolean (i.e. dtype == np.bool) mask containing True and
                 False representing which parts of im1 and im2 should appear
                 in the resulting im_blend.
    :param max_levels:  is the max_levels parameter you should use when
                        generating the Gaussian and Laplacian pyramids.
    :param filter_size_im: is the size of the Gaussian filter (an odd scalar
                           that represents a squared filter) which defining the
                           filter used in the construction of the Laplacian
                           pyramids of im1 and im2
    :param filter_size_mask: is the size of the Gaussian filter
    :return: The blended image.
    """
    image_1 = read_image(relpath(image1_name), 2)
    image_2 = read_image(relpath(image2_name), 2)
    im_blend = np.empty(image_1.shape, dtype=np.float64)
    mask = np.round(read_image(relpath(mask_name), 1)).astype(np.bool)

    im_blend[:, :, 0] = pyramid_blending(image_1[:, :, 0], image_2[:, :, 0],
                                         mask, max_levels, filter_size_im,
                                         filter_size_mask)

    im_blend[:, :, 1] = pyramid_blending(image_1[:, :, 1], image_2[:, :, 1],
                                         mask, max_levels, filter_size_im,
                                         filter_size_mask)

    im_blend[:, :, 2] = pyramid_blending(image_1[:, :, 2], image_2[:, :, 2],
                                         mask, max_levels, filter_size_im,
                                         filter_size_mask)

    plt.figure()
    plt.subplot(221).imshow(image_1)
    plt.subplot(222).imshow(image_2)
    plt.subplot(223).imshow(mask, cmap='gray')
    plt.subplot(224).imshow(im_blend)
    plt.show()
    return image_1, image_2, mask, im_blend


def blending_example1():
    """
    This function is the first blending example.
    :return: im1, im2, mask and the im_blend.
    """
    return blending_images("externals/ryan.jpg", "externals/lenna.jpg",
                           "externals/mask_1.jpg", 5, 5, 5)


def blending_example2():
    """
    This function is the first blending example.
    :return: im1, im2, mask and the im_blend.
    """
    return blending_images("externals/forest_gump.jpg", "externals/lecture.jpg",
                           "externals/mask_2.jpg", 5, 5, 5)
